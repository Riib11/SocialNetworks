{"entities":["Booting","CPU cache","Cache (computing)","Data deduplication","Disk image","Fingerprint","Hypervisor","Online and offline","Public key fingerprint","Random access","Read-write memory","Run time (program lifecycle phase)","Semiconductor consolidation","Throughput","Virtual disk","z/VM"],"journalVolume":"","journalPages":"214-227","pmid":"","year":2017,"outCitations":["26497a6800ece4c608b0fd4d42fab6ae3a9d7af6","612a8604f26c32457f47e52aa4675fd5dab84c7c","4e8839416133588c10cc56d6325db55a42fe2215","242b5b545bb17879a73161134bc84d5ba3e3cf35","92a6961f076307d5b4778fd45d5f01f6d5d84e12","d7df6cc3a35b4a5b9bc95aacdcad810288f11f9b","bb90aa0bd362d615e3598f52504d06b20125512d","0c279813f1dba545c50c237f69b89c6496117015","7c0699937a1775a01ee8ec97ca30f5427f020b99","86337138bb6dfabef8e1d45ec3c4e30d64c3ce36","02cc5b5ad2d7ca9f83c9e566bcb5f9b608ab0619","b522597f20f69526bb748a2b592d8db8e9983dac","898b60ae12a855ac9ad91f93543d82ce00ee76ff","67b2c85458667cb15c13beb66d1559f39637c145","16444e411e3e33bf7cb3b813f76834fc3dd87d72","bf6275801e4bac2918f1b8698c2892e1a375808f","10d011c92b87833ac2186b963c0bf5e039cd6c7e","0a9a3fa7b948f12555e0df34069cbd8c7e752cac","4c664c7015285ce14063204d0790dffbb7bbf46c","481086af0ac174dc0416bc7daf33100fab5c649b","0ce479229630e55e732597cf9b2aeb5018aae4c2","045729ec838ecc50be166fe4511506ac4a08226d","3574657705475722b6c398c266805f758268778b","18eadfc4a6bcffd6f1ca1d1534a54a3848442d46","2f2cdd7b0c98b5e43b61272d2ac3ebb5cd29041d","3ab540622889dec61a3f98bf9990f62b80492dc0","3437a7e23e3f97b58f4cf73e7e5b711131e6706c","2918c9f078aa5dfa0a8ea08ba689aa7a45d9d21c","07042865b10297ca4fc9164829d6330db2f60b4c","445728ecb0eabed9f7433b0c96bd36d53cb312c9","1506e49a71ffcc4d201928dbc76a881608c9c6c4"],"s2Url":"https://semanticscholar.org/paper/be001fe8d3823490417e0866331dba500520f5eb","s2PdfUrl":"","id":"be001fe8d3823490417e0866331dba500520f5eb","authors":[{"name":"Chun Yang","ids":["2131120"]},{"name":"Xianhua Liu","ids":["6293765"]},{"name":"Xu Cheng","ids":["39423013"]}],"journalName":"","paperAbstract":"Storage consolidation in a virtualized environment introduces numerous duplications in virtual disks and imposes considerable pressure on disk I/O and caching. In this paper, we present a content look-aside buffer (CLB) approach for simultaneously providing redundancy-free virtual disk I/O and caching. CLB attaches persistent fingerprints to virtual disk blocks, which enables detection of I/O redundancy before disk access. At run time, CLB exploits content pages already present in the guest disk caches to service the redundant reads through page sharing, thus eliminating both redundant I/O requests and redundant disk cache copies. For write requests, CLB uses a group invalidating writeback protocol for updating fingerprints to support crash consistency while minimizing disk write overhead. By implementing and evaluating a CLB prototype on KVM hypervisor, we demonstrate that CLB delivers considerably improved I/O performance with realistic workloads. Our CLB prototype improves the throughput of sequential and random read on duplicate data by 4.1x and 26.2x, respectively. For typical read-intensive workloads, such as booting VM and launching application, CLB's I/O deduplication and cache deduplication eliminates 94.9%--98.5% of read requests and saves 50%--100% cache memory in each VM, respectively. Compared with the QEMU's raw virtual disk format, CLB improves the per-disk VM density by 8x--16x. For mixed read-write workloads, the cost of on-line fingerprint updating offsets the read benefit; nevertheless, CLB substantially improves overall performance.","inCitations":[],"pdfUrls":["http://doi.acm.org/10.1145/3050748.3050762"],"title":"Content Look-Aside Buffer for Redundancy-Free Virtual Disk I/O and Caching","doi":"10.1145/3050748.3050762","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050762","venue":"VEE"},
{"entities":["Autoscaling","Data center","Data structure","Elasticity (cloud computing)","Experiment","Hypervisor","Lock (computer science)","Memory scrubbing","Non-uniform memory access","Scalability","Semiconductor consolidation","Signal trace","Speedup","Swift (programming language)","Unikernel","Virtual machine"],"journalVolume":"","journalPages":"1-14","pmid":"","year":2017,"outCitations":["0e851f49432767888b6ef4421beb268b9f2fc057","0327e79a9863898a2dd24a7d1850ec3bedf044d0","150a59b0904b5725c69302dbfba148fbf67be2b0","11928ecc96f52e153f6a3bf5143260f15f7c4dfd","504b4cc991475ebde762d3bb24316b9fe6b92fa6","067c7857753e21e7317b556c86e30be60aa7cac0","2763cd85a279d9aa28942eb51febaa76c2c852cb","3574657705475722b6c398c266805f758268778b","08832863bc3f041222f381c8ae143f8a66449059","4650259fb4aadb376fd5994f9ab9dd07a4f83511","36560510bab4e9e6d8660b91189f9e11e486f1c4","3bc68ebdfc30f1e5df9a80b48bdfde1e20e0ccbe","ce8f8e86db523da990507f177c6c6df445cd8d46","41fca6c199464c983cb6384ae65c83eb7522fb46","0187493c5cbd9b8bcf2019b8521082aea6db83f1","0d41dcafa87195ae3c05282b5250bc639d31de87","54ff8026f68506452bb19585773935b4f1e71aa4","69bcfe3e8c989166caa93c78637a19793ac43eee","280863f80b6401bc6d65839ecb3dc7a0febdfa09","54be24210d49deeed59a0bd53c6f1704d0db9e33","3cc9d8e25164012d0c1a61d28293b36a4b9d8759","4e4348913b3198ae51b784db893938ae3afecaf5"],"s2Url":"https://semanticscholar.org/paper/6895a7a7ef3a9c8e77b5f6ee8c64b49d2dee61cc","s2PdfUrl":"","id":"6895a7a7ef3a9c8e77b5f6ee8c64b49d2dee61cc","authors":[{"name":"Vlad Nitu","ids":["32426008"]},{"name":"Pierre Olivier","ids":["2127809"]},{"name":"Alain Tchana","ids":["1685006"]},{"name":"Daniel Chiba","ids":["10399629"]},{"name":"Antonio Barbalace","ids":["1759838"]},{"name":"Daniel Hagimont","ids":["1679417"]},{"name":"Binoy Ravindran","ids":["1729107"]}],"journalName":"","paperAbstract":"The ability to quickly set up and tear down a virtual machine is critical for today's cloud elasticity, as well as in numerous other scenarios: guest migration/consolidation, event-driven invocation of micro-services, dynamically adaptive unikernel-based applications, micro-reboots for security or stability, etc.\n In this paper, we focus on the process of setting up/freeing the hypervisor and host control layer data structures at boot/destruction time, showing that it does not scale in current virtualization solutions. In addition to the direct overhead of long VM set-up/destruction times, we demonstrate by experimentation the indirect costs on real world auto scaling systems. Focusing on the popular Xen hypervisor, we identify three critical issues hindering the scalability of the boot and destruction processes: serialized boot, unscalable interactions with the Xenstore at guest creation time, and remote NUMA memory scrubbing at destruction time. For each of these issues we present the design and implementation of a solution in the Xen infrastructure: parallel boot with fine-grained locking, caching of Xenstore data, and local NUMA scrubbing. We evaluate these solutions using micro-benchmarks, macro-benchmarks, and real world datacenter traces. Results show that our work improves the current Xen implementation by a significant factor, for example macro-benchmarks indicate a speedup of more than 4X in high-load scenarios.","inCitations":["df545215b7e7f830adc96f4c72566d22a68a9f06","70c4f0403d80427e10c7e7167f814ec0bb12d18f"],"pdfUrls":["http://doi.acm.org/10.1145/3050748.3050758"],"title":"Swift Birth and Quick Death: Enabling Fast Parallel Guest Boot and Destruction in the Xen Hypervisor","doi":"10.1145/3050748.3050758","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050758","venue":"VEE"},
{"entities":["Amazon Elastic Compute Cloud (EC2)","CMA-ES","Docker","Full virtualization","GIOVE","Hypervisor","InfiniBand","Locality of reference","Loopback","OpenVMS","Operating-system-level virtualization","Shared memory","Supercomputer","Virtual machine","X86 virtualization"],"journalVolume":"","journalPages":"187-200","pmid":"","year":2017,"outCitations":["0fc0910aba6a5690059843fd72e99c871a16a577","3b7e2038ec22cf637df70c833d473b0f3b43713a","3e072004786e19f4f3d8918fd7483c9e12e4d4ef","71dec883ad8effe7d6075512138625080d32ab47","03ed30028164bd7b5215da3fb431f4402071a49f","0007f817593d82a859f2aa2ba1d1ee7e9199e190","54cff2c17f8c24508ef82aa8ef2d7ed3fcc5db97","192fec9d330de17828caba1d2a44983ca414c900","6678b17fc8758efea8d32c2d47f9924f8a0cdc6d","59d45d685e35f5a84768c029ea09b9c48765251e","0abc3e83ccd6e685f8d0299f24f03ae28f4c2459","62b757b1a924f3386c33b8a988327e3749ab8a54","010c1b6fad2e47868b22f3787e2f355875f10cec","3135e5342bbde77d7c734456dae974e2bb5928e3","aaee60074480179a69f1891a02698632d788613d","855b6f36f8b7da5451dc853f9bf0e8babcf25eb3","0d9aea55a54ccc6ab64995d70bf6ae464af25f0d","01da9f866f2bf8a7c9319994075c0f7ea199e1ff","a7298ad92e7f58242f3e43007fe12389e19b29a3","97f355e50deffa3416b34dba7f2e3ab505ac8b2d"],"s2Url":"https://semanticscholar.org/paper/f4cf3c8b8bbc0e98be827b90628a7f2a9ab413dd","s2PdfUrl":"","id":"f4cf3c8b8bbc0e98be827b90628a7f2a9ab413dd","authors":[{"name":"Jie Zhang","ids":["1698586"]},{"name":"Xiaoyi Lu","ids":["1720335"]},{"name":"Dhabaleswar K. Panda","ids":["1731654"]}],"journalName":"","paperAbstract":"Hypervisor-based virtualization solutions reveal good security and isolation, while container-based solutions make applications and workloads more portable and distributed in an effective, standardized and repeatable way. Therefore, nested virtualization based computing environments (e.g., container over virtual machine), which inherit the capabilities from both solutions, are becoming more and more attractive in clouds (e.g., running Docker over Amazon EC2 VMs). Recent studies have shown that running applications in either VMs or containers still has significant overhead, especially for I/O intensive workloads. This motivates us to investigate whether the nested virtualization based solution can be adopted to build high-performance computing (HPC) clouds for running MPI applications efficiently and where the bottlenecks lie. To eliminate performance bottlenecks, we propose a high-performance two-layer locality and NUMA aware MPI library, which is able to dynamically detect co-resident containers inside one VM as well as detect co-resident VM inside one host at MPI runtime. Thus the MPI processes across different containers and VMs can communicate to each other by shared memory or Cross Memory Attach (CMA) channels instead of network channel if they are co-resident. We further propose an enhanced NUMA aware hybrid design to utilize InfiniBand loopback based channel to optimize large message transfer across containers when they are running on different sockets. Performance evaluations show that compared with the performance of the state-of-art (1Layer) design, our proposed enhance-hybrid design can bring up to 184%, 81% and 12% benefit on point-to-point, collective operations, and end applications. Compared with the default performance, our enhanced-hybrid design delivers up to 184%, 85% and 16% performance improvement.","inCitations":["8a702304f6964ad5abdb1c4b19e6a645738a4474","0351f22135e61de52250654b1f8b277cd8c7a173","01d7b1187d8593983181d18c357ffbed9c6ac8ac"],"pdfUrls":["http://doi.acm.org/10.1145/3050748.3050765"],"title":"Designing Locality and NUMA Aware MPI Runtime for Nested Virtualization based HPC Cloud with SR-IOV Enabled InfiniBand","doi":"10.1145/3050748.3050765","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050765","venue":"VEE"},
{"entities":["CUDA","Computer vision","Embedded system","Field-programmable gate array","Floating Point Systems","General-purpose computing on graphics processing units","Hardware acceleration","OpenCL API","Parallel computing","Programming language","Quality of service","Runtime system","Software portability"],"journalVolume":"","journalPages":"74-82","pmid":"","year":2017,"outCitations":["a8e9034fc1828719e98e41fda539faf8d56bf47f","6074c1108997e0c1f97dc3c199323a162ffe978d","4a088b3ef14d19448e77008f852f2e9805ffc1ea","907d2c011942a78bf6acff8e048f4185d53ff8f2","0f58afdae0b5d40a599d685c81c83f33586c671a","00a9ba0063d34ec56792849a67ef57b4601becbb","711fbb31886c767aa7842b7779b373156259a2e7","7bbbbd2073503720f304d031cb4641eb45a3edee","0a714abfcf37a2a37f2d533563b2eed19e8b801b","28c552da5dc505fe23644cfddf7daaf06c355e45","d57b42821ec782b33dd49ee0c37976bbd62d24a4","98e5f816dc8f4d8ee31824669e20586b78b9f15c","1850ceb5376a4a14a7d77031789ef3ccb4f87e93","0259607cc9a2ad28592e77543e5433bb3d87a70c","a19a7c5e45125a570dcbac018184669b8cab2789","282cf28ac9508bd66a6ddf0709c9db9dc0fdf162","d440bdc8a46e57c7c0922ef6dfef68dd9fb6ae65","30abed73bf3d442d4d17c0a843ad59679dc3c79e","53dcc743e94ed14c3e94382f994bdd2e948a1b5c","0a9c4656948693f5e11c4c092303abe54da50caf","09ea2e8942f624a6dad4c96f3c62320fbb0db7a8","4726ec683a7db8e97ebd845b98e294ead537888a","236fb3e74fa802e44541edb76bee5886397acc7a","5d5e1b35dcfbf52299c327baab696568ba0e1d15"],"s2Url":"https://semanticscholar.org/paper/e0f74ac8cc27da3966ac3cc8b4e0cec1df3f576d","s2PdfUrl":"","id":"e0f74ac8cc27da3966ac3cc8b4e0cec1df3f576d","authors":[{"name":"Christos Kotselidis","ids":["1963560"]},{"name":"James Clarkson","ids":["40844251"]},{"name":"Andrey Rodchenko","ids":["2322572"]},{"name":"Andy Nisbet","ids":["2476643"]},{"name":"John Mawer","ids":["1865829"]},{"name":"Mikel Luján","ids":["1706226"]}],"journalName":"","paperAbstract":"Real-time 3D space understanding is becoming prevalent across a wide range of applications and hardware platforms. To meet the desired Quality of Service (QoS), computer vision applications tend to be heavily parallelized and exploit any available hardware accelerators. Current approaches to achieving real-time computer vision, evolve around programming languages typically associated with High Performance Computing along with binding extensions for OpenCL or CUDA execution.\n Such implementations, although high performing, lack portability across the wide range of diverse hardware resources and accelerators. In this paper, we showcase how a complex computer vision application can be implemented within a managed runtime system. We discuss the complexities of achieving high-performing and portable execution across embedded and desktop configurations. Furthermore, we demonstrate that it is possible to achieve the QoS target of over 30 frames per second (FPS) by exploiting FPGA and GPGPU acceleration transparently through the managed runtime system.","inCitations":["55c143f5b991501a09a644ab0f39c05951ae4754","28004163c4d4646b66079d6810d3159dd1106999","653e56eafd7001abd35f96cb317d790a835248f2","d440bdc8a46e57c7c0922ef6dfef68dd9fb6ae65"],"pdfUrls":["http://doi.acm.org/10.1145/3050748.3050764"],"title":"Heterogeneous Managed Runtime Systems: A Computer Vision Case Study","doi":"10.1145/3050748.3050764","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050764","venue":"VEE"},
{"entities":["32-bit","64-bit computing","ARM architecture","Binary translation","Computer architecture","Hypervisor","Memory management","Operating system","PowerPC","SPARC","Single user mode","User space","X86","X86-64"],"journalVolume":"","journalPages":"228-241","pmid":"","year":2017,"outCitations":["078d90580b1d01ac8f4adc2b14cfa8661b0af8e4","e1ac84461475bb2c7c89f63bdced533556b8671f","898636295f0cb2a1cd96e83796d4e2b5a05d7124","0856f6f40b889dba559f19654834114e9f469760","66639a71451c34cc01bb3bca2bf029ebe7d5d48e","152c1893389e244ddaa7dd47c247b9c4c72ca7d8","0a65844b2e318305c7031eb53cb306efe7763d22","5f6a808bedd3dbfd1290063b3cd8221132ce5c95","02e9d10ea0e3414146d946e8d4b0d196cef6e875","f016d23ffca72cdf1eb584613452720eaacafd9c","da1b0f589e925481ef74ec778c2b597be0b7b54e","47dc52eeb7bf6efb46c550201cc8d52af71cc1a3","9b9077f5cccbdfe5cebe1a7a3a43bc1665dcb8b7","34eb2d9daf746f32409b88fcd974f0cf19c4341c","55517b0c1f9755691ab471fa79ecf25d1928d540","da33e45c803199b6c5ed2acf76d1b6ea4dcaa66a","067c7857753e21e7317b556c86e30be60aa7cac0","109df0e8e5969ddf01e073143e83599228a1163f","0b0422b5864ca1a25d6af274bad11c1b2fef1ed5","50bfb732ff36296243832c43936158bc9ba96dfe","ffdec1d45b9395ccb074fc0de65a799aa937ac50","2549f9b455f75ebaaa3736208e319847140b705e","1898169191c2030e1c1e442afbb66610281f328f","0317e2e18d66839df7348298e80aff7f3ad5ab28","6d12aea56165acf3715e2c82b5f560e48359366d","80ab97b9c2f8f74795b11fa50aa0ad7f37975c0e","fbd7f49a8df330e17f7fdff08a59e93d32f50502","0653e2ed9f683868cb4539eb8718551242834f6b","650c4aa6fcfec595f8bb7b3f6015f1f31a4320be","0ef6f7fa8f12e408c928c371c07ccbc3fcade91d","07ebe9df86f0e6eb19fcdd03bbe9dd7f64ff887f","dcb54653a7f348c16f110a9f5de7533fa3476495","71a2d8c473f13d0c664f751db97e81128281b1eb"],"s2Url":"https://semanticscholar.org/paper/9bb1f695e399d030ba188b29b546cd9b26039715","s2PdfUrl":"","id":"9bb1f695e399d030ba188b29b546cd9b26039715","authors":[{"name":"Amanieu D'Antras","ids":["2865352"]},{"name":"Cosmin Gorgovan","ids":["2751492"]},{"name":"Jim D. Garside","ids":["1778171"]},{"name":"John Goodacre","ids":["2940048"]},{"name":"Mikel Luján","ids":["1706226"]}],"journalName":"","paperAbstract":"Current computer architectures --- ARM, MIPS, PowerPC, SPARC, x86 --- have evolved from a 32-bit architecture to a 64-bit one. Computer architects often consider whether it could be possible to eliminate hardware support for a subset of the instruction set as to reduce hardware complexity, which could improve performance, reduce power usage and accelerate processor development. This paper considers the scenario where we want to eliminate 32-bit hardware support from the ARMv8 architecture.\n Dynamic binary translation can be used for this purpose and generally comes in one of two forms: application-level translators that translate a single user mode process on top of a native operating system, and system-level translators that translate an entire operating system and all its processes.\n Application-level translators can have good performance but is not totally transparent; system-level translators may be 100% compatible but performance suffers. HyperMAMBO-X64 uses a new approach that gets the best of both worlds, being able to run the translator as an application under the hypervisor but still react to the behavior of guest operating systems. It works with complete transparency with regards to the virtualized system whilst delivering performance close to that provided by hardware execution.\n A key factor in the low overhead of HyperMAMBO-X64 is its deep integration with the virtualization and memory management features of ARMv8. These are exploited to support caching of translations across multiple address spaces while ensuring that translated code remains consistent with the source instructions it is based on. We show how these attributes are achieved without sacrificing either performance or accuracy.","inCitations":["9b9077f5cccbdfe5cebe1a7a3a43bc1665dcb8b7","31284eda208c225f41987d33c77f547f1e1135ce"],"pdfUrls":["http://doi.acm.org/10.1145/3050748.3050756"],"title":"HyperMAMBO-X64: Using Virtualization to Support High-Performance Transparent Binary Translation","doi":"10.1145/3050748.3050756","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050756","venue":"VEE"},
{"entities":["Application checkpointing","Garbage collection (computer science)","Location-based service","Memory management","Memory management unit","Memory protection","Page (computer memory)","Program analysis","Virtual machine"],"journalVolume":"","journalPages":"201-213","pmid":"","year":2017,"outCitations":["16a9c88fad400497635ce4736679abb3c48c84d2","0e55379d27454c5d9d72e4ba4b3752007b9f886f","984d45494026f7a2fc9c4193ee65b5ef35d937ad","4fe68f0468d4e6a47cd7f747f49c307dea87cd89","2194c3460ab71f3826db00b045b2ae590c753319","624168bb99821e7c9fef722c1758ceda42eba33f","04a953ba760845232c0f3c6e4dc3ca7b1fb8da4e","13f6ddd72bcf62dcc13cf4515be29d48948b9693","1d15930cd9e4ececf22fd96bf9ba52f12dc0665e","fcae2fcef595059529ebe553431ab41b44062ae4","27650fee2ed40f0e6c214ca112bffd9164b2e0b5","e67d7810e9f7baad696e1e5be0c9f1dde39a178d","f6715c2d9d8a76a20f4b857f7377ce63a23f0654","1591e9cf9c5d5fa42e7b5e48bd76f43a0a6e8f0b","03e93625d185c0ac144c97fdf269b5ae5f38351e","2a974da13d6f956e37549378e00f86aa54bc5642","ae041f8e6228f0ccd8b01ffdeba150e63635c2c4","c4e77ec0e6e4ac6638b662bfe5342439ad4451de","0c0ff71e1f225312bd24a2d78153f0b3f3816285","2c74aeec68efd07d908d4f421a5d4afe8426a18c","2346439ece014d5e3ce1564adc2a7ca098a37c8e","3574657705475722b6c398c266805f758268778b","0653e2ed9f683868cb4539eb8718551242834f6b","2a9d09d8e2390c92cdaa5c8b98d6dd4cb394f638","40cb40b7812e019c1051e3a457a8643400b81d51"],"s2Url":"https://semanticscholar.org/paper/3b38eff9030f362bc0337501f562187479dbb0dd","s2PdfUrl":"","id":"3b38eff9030f362bc0337501f562187479dbb0dd","authors":[{"name":"Kai Lu","ids":["1769447"]},{"name":"Wenzhe Zhang","ids":["2128414"]},{"name":"Xiaoping Wang","ids":["1683712"]},{"name":"Mikel Luján","ids":["1706226"]},{"name":"Andy Nisbet","ids":["2476643"]}],"journalName":"","paperAbstract":"Page protection is often used to achieve memory access monitoring in many applications, dealing with program-analysis, checkpoint-based failure recovery, and garbage collection in managed runtime systems. Typically, low overhead access monitoring is limited by the relatively large page-level granularity of memory management unit hardware support for virtual memory protection. In this paper, we improve upon traditional page-level mechanisms by additionally using hardware support for virtualization in order to achieve fine and flexible granularities that can be smaller than a page. We first introduce a memory allocator based on page protection that can achieve fine-grained monitoring. Second, we explain how virtualization hardware support can be used to achieve dynamic adjustment of the monitoring granularity. In all, we propose a process-level virtual machine to achieve dynamic and fine-grained monitoring. Any application can run on our process-level virtual machine without modification. Experimental results for an incremental checkpoint tool provide a use-case to demonstrate our work. Comparing with traditional page-based checkpoint, our work can effectively reduce the amount of checkpoint data and improve performance.","inCitations":[],"pdfUrls":["http://doi.acm.org/10.1145/3050748.3050751","https://www.research.manchester.ac.uk/portal/files/56101450/vee2017_checkpointing.pdf"],"title":"Flexible Page-level Memory Access Monitoring Based on Virtualization Hardware","doi":"10.1145/3050748.3050751","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050751","venue":"VEE"},
{"entities":["ARM architecture","Commodity computing","Decoupling (electronics)","Hypervisor","Juno (company)","KVM switch","Linux","Linux","Memory protection","Page table","Performance Evaluation","Task Control Block","Virtual machine","X86"],"journalVolume":"","journalPages":"242-256","pmid":"","year":2017,"outCitations":["2f484f6f079faefef1a8acf26383ecdb019fd380","39040e2b60fcb01dfed8d638f2cb66218cfdb144","79e14bf42535966db5e056af6d8a0e0ec1f522b2","0829638686dfef02a9ded604952173f06b1ab1aa","56777045bdfcf386c037e1884660180dc3c255ae","565a174a24e7f47dcd7a21f57cabc252b5692a0f","3c4e907c07944cd55e800b4e55918adf8cb2a683","a5fa4c155172dc544dedd0dd2cfb67d52156e906","2b3cdf37bff57e29fb5aecc136603f16c855366b","44a2ee04d8b939978bd892249c459aec5672412e","0dac671dae4192cfe96d290b50cc3f1105798825","080c336698f5d7a15169e5ad98fa62a0bbf6085c","0b0422b5864ca1a25d6af274bad11c1b2fef1ed5","1fb49ae43195232f0b3d1c9d534a5aa03bdd8f26","4ce02fb69245a84d3ffceae20e596dcf0497508d","765c5d29bce0617e78b2ec3e918e31f6e543645e","008ff29ee4dbee79028e1017d6459347ad8f45d6","05f70f429a7bf38efa9e457fd486cb862bd495be","0d844dec1c0e7b56c178fbb09945001ba00e0d05","6c0562ffc00ba7a4d2734ac039ffd181afe2008d","089895ef5f96bdb7eed9dd54f482c22350c2f30d","2fcdec58c1c0028e07c4823cf082fd6d3abc05dc","36b1e5a0e61fdaf6ca5c56015db2376d87db376b","90df476a4070cd797ef682f30a408086899ad16b","173bd678095821c34781c6649ccc7206d346f219","78ff3d73248e53e3abab2c3bf6e09730f04d1415","10e0397e08f37ee5d3ba1f9e24ac9eb313c784f4","5693c2a2c52f4905638559b2fc2b76c975806175","24657cf3a48c7fde2f9611ebee271fecc8be9952","ec79422e0bfdb61d8b6d2a6ec5b2dfbcab970852","30f52a79ff53f8969ffcba19013b4a43e629875f","2e8da51c545cbe8e62a3751a5a2b9a3beca00b43","e1d9c149fa0d3f3014db2cd554a5602dced982cd","8f7b97fa428c0156a8220df5034650c4c77933d2","83029e6400054bb286c3188aee4434923f6dc9ea","6d6bd93c620885cb5ddd5abfac19efffac132cd5","5bddb52a9def1c1330e8139b8496fbb8bb8c5937","85d555f7ce19740b4fc656ff797623c6e1513018","3b06edbeb2adf0de12a6ddbec073fd96e82617c6","5af5aa924c170d30e9203801e97ebe347700c3a9","505ee623397666c0ce158e103ffac0c62dbcf2fa","46bc4d7c5605e8468f4355335416e15f0d7e4dcd","1251fe24e96d5c12f868bf4584351c0ee03d55ec","b1b3c8f907db6748c373bf1d15ec0c15bb2307dc","22a5eeb8608b35e371b7544a54fabeadca8866e3"],"s2Url":"https://semanticscholar.org/paper/fe7aa435d3cd3a667b8cf31f5e327a2c4b479286","s2PdfUrl":"","id":"fe7aa435d3cd3a667b8cf31f5e327a2c4b479286","authors":[{"name":"Min Zhu","ids":["38728459"]},{"name":"Bibo Tu","ids":["1794873"]},{"name":"Wei Wei","ids":["1725923"]},{"name":"Dan Meng","ids":["1693956"]}],"journalName":"","paperAbstract":"Once compromising the hypervisor, remote or local adversaries can easily access other customers' sensitive data in the memory and context of guest virtual machines (VMs). VM isolation is an efficient mechanism for protecting the memory of guest VMs from unauthorized access. However, previous VM isolation systems either modify hardware architecture or introduce a software module without being protected, and most of them focus on the x86 architecture.\n This paper proposes HA-VMSI, a lightweight hardware-assisted VM isolation approach for ARM, to provide runtime protection of guest VMs, even with a compromised hypervisor. In the ARM TrustZone secure world, a thin security monitor is introduced as HA-VMSI's entire TCB. Hence, the security monitor is much less vulnerable and safe from attacks that can compromise the hypervisor. The key of HA-VMSI is decoupling the functions of memory isolation among VMs from the hypervisor into the security monitor. As a result, the hypervisor can only update the Stage-2 page tables of VMs via the security monitor, which inspects and approves each new mapping. It is worth noting that HA-VMSI is more secure and effective than current software approaches, and more flexible and compatible than hardware approaches. We have implemented a prototype for KVM hypervisor with multiple Linux as guest OSes on Juno board. The security assessment and performance evaluation show that HA-VMSI is effective, efficient and practical.","inCitations":[],"pdfUrls":["http://doi.acm.org/10.1145/3050748.3050767"],"title":"HA-VMSI: A Lightweight Virtual Machine Isolation Approach with Commodity Hardware for ARM","doi":"10.1145/3050748.3050767","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050767","venue":"VEE"},
{"entities":["Big data","Central processing unit","Computation","Graphics processing unit","Heterogeneous computing","High- and low-level","Just-in-time compilation","Library (computing)","Low-level programming language","Manycore processor","OpenCL API","Partial evaluation","Profiling (information science)","Programmer","Programming language","R language","Run time (program lifecycle phase)","Uptime"],"journalVolume":"","journalPages":"60-73","pmid":"","year":2017,"outCitations":["d4defe055ddaf9d84e453598ad75529709c64b70","5231091fd9fe75115bedf967fa8ed95810ae6ae3","3e129f0194279d49056c737e0caa97af25a5f1aa","642da427e4fc7a0d62e239c561cc28821c341d50","a1be5e4b91ee22100ac946c007d71266a4399502","8d19166630b77df25624ba64cfa5dbdc6cd9aba8","7e007883306b2d0b8da57ed608f5441dcc30a3e2","9ad48bd155815ad662e10e1228557d9ec9846828","1850ceb5376a4a14a7d77031789ef3ccb4f87e93","14505c2bdd3822d7a62385121d28ba3eb36fea1d","4a088b3ef14d19448e77008f852f2e9805ffc1ea","2fa4722b81b63c4973ecc7a327f4c827f34d2c5e","1f7ad334ee1b933fcd2917f97a1b2eb97c8e44c2","a3e88aa2505c1f4e7f176b1afa467c60fd30bdac","74a271cc13ccbdb1842f56ddb6faa144046e84d3","5d5e1b35dcfbf52299c327baab696568ba0e1d15","c17ac40f0fb475c810c70a52b3dd6535454eabf4","0f58afdae0b5d40a599d685c81c83f33586c671a","26b612d9c0f3c1b88394ebf299a450e73594b5dc","53e2b31ad6fea91655ecbe64fe66968b934d0160","7521513abd7acae00b3fd89001da47019606cf38"],"s2Url":"https://semanticscholar.org/paper/027188ede13c9f29bea0710921f7c341f045a75b","s2PdfUrl":"","id":"027188ede13c9f29bea0710921f7c341f045a75b","authors":[{"name":"Juan José Fumero","ids":["2061911"]},{"name":"Michel Steuwer","ids":["1795890"]},{"name":"Lukas Stadler","ids":["6503919"]},{"name":"Christophe Dubach","ids":["3224333"]}],"journalName":"","paperAbstract":"Computer systems are increasingly featuring powerful parallel devices with the advent of many-core CPUs and GPUs. This offers the opportunity to solve computationally-intensive problems at a fraction of the time traditional CPUs need. However, exploiting heterogeneous hardware requires the use of low-level programming language approaches such as OpenCL, which is incredibly challenging, even for advanced programmers.\n On the application side, interpreted dynamic languages are increasingly becoming popular in many domains due to their simplicity, expressiveness and flexibility. However, this creates a wide gap between the high-level abstractions offered to programmers and the low-level hardware-specific interface. Currently, programmers must rely on high performance libraries or they are forced to write parts of their application in a low-level language like OpenCL. Ideally, nonexpert programmers should be able to exploit heterogeneous hardware directly from their interpreted dynamic languages.\n In this paper, we present a technique to transparently and automatically offload computations from interpreted dynamic languages to heterogeneous devices. Using just-in-time compilation, we automatically generate OpenCL code at runtime which is specialized to the actual observed data types using profiling information. We demonstrate our technique using R, which is a popular interpreted dynamic language predominately used in big data analytic. Our experimental results show the execution on a GPU yields speedups of over 150x compared to the sequential FastR implementation and the obtained performance is competitive with manually written GPU code. We also show that when taking into account start-up time, large speedups are achievable, even when the applications run for as little as a few seconds.","inCitations":["fc43b21e3582dee88e364a6dff2441ad366c43f5","55c143f5b991501a09a644ab0f39c05951ae4754"],"pdfUrls":["http://www.research.ed.ac.uk/portal/files/33009999/vee.pdf","http://doi.acm.org/10.1145/3050748.3050761","http://eprints.gla.ac.uk/146598/7/146598.pdf"],"title":"Just-In-Time GPU Compilation for Interpreted Languages with Partial Evaluation","doi":"10.1145/3050748.3050761","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050761","venue":"VEE"},
{"entities":["Data deduplication","FreeBSD","Linux","Linux","Open-source software","Program optimization","System call","Virtual Machine Manager"],"journalVolume":"","journalPages":"112-128","pmid":"","year":2017,"outCitations":["7c0699937a1775a01ee8ec97ca30f5427f020b99","2387968d22927a79d5d601107e70220763fc6e12","5bb770af1973f929e8622f17ddf378d439245144","340569da290505865cb2ba79a4201c7028d4d66a","4a7872f0177e00c1c3621be90b72299fc3498474","043029ff68d0449eacae8a67fc62ed4ee03215a2","26497a6800ece4c608b0fd4d42fab6ae3a9d7af6","0e316f76dac185ee2d922e64d4659b2e36842196","ec20eb666574a97d3c7f85d988589b0fb8ee5466","a3676ecae39afd35b1f7075fc630e28cfbb5a188","2c628dedb6a1fb0c566ec791c84b93a22dd9aaa9","3946a5c410ba1980d932cc6d2987b4d935e038d5","bb5e43dd30a3a60df42652d56781568f5cd0a99d","03612ec719ad7b08a64ad2110e77fcaa1814eb5b","40f91d7d050bb8f92e06039c20f150fde9674eaa","4ab4a666f5e5ed34ac219a9fdc2f70bd1cab0922","0b6adc0dbc55076dc9c9a8931f4a4df58fd291b6","a658f8bd1abaf8f06183266d13de25f0559c9592","3e29cdcdb12ffdb80a734d12c905c1df43e0b6a4","755cd7170315ce736f556a79ce36296e5b9bf030","e0508499b4cf5794d5aeaf717e7ad9541e9c2bba","2960c89331eb7afa86584792e2e11dbf6a125820","1354abf8baa8b6d39c65758072ae9d0b07227d5c","27f071ccbea5a4940dcc585ba4cfa9258bf2bcdf","4096f239b93dfee8fe033db2846a334db9c1f524","67b2c85458667cb15c13beb66d1559f39637c145","67ed19a01c5fa2a2000dfb07e821c3e98728367d","4f27ece79537ebf5f8e4c8d8429b81ae59082035","9c48179c07963a9fad69a359362c0aee87f9fe18","04aae75ab8a040225024b6a96ab7cbb28ef74d0a","0edd896bc82b7fb65ef63cb1e3512db795c7f7d4","1e875b3536e3c8bcd976bc27d8c8a4d06e849626","5ff311923cd8f80057b2cfc15cf7ec3ac0a6fdbc","65a2cb8a02795015b398856327bdccc36214cdc6","4b4ee1ee9bbfd9527fba0bbd761bd61a59f96a48","02ed0ec3bb95776b5c06e2784810b501c4d3f053","ea5bb6cf0b63c643e5325ee2bef143d2ca450f3d","511feec4f8875108f093c0b91ffe1d841423bdde","c2bc2e165fe6af3de5de600af57cb0b301ce0c0f","1ee3e65a3e5cb1b814a39258aa0f7cb60a51f955","a35295a26ded98e5649a94a8ad03baa8cc8d9dd3","94a62be8355bf5be1edcc881a26559e5258e0f1d","612a8604f26c32457f47e52aa4675fd5dab84c7c","0ce479229630e55e732597cf9b2aeb5018aae4c2","045729ec838ecc50be166fe4511506ac4a08226d","3574657705475722b6c398c266805f758268778b","1346e4134764c1d226c357dce3f9a58c55909719","009af3a1fa932ea1a9efa8d34cb0b6e32feae15e"],"s2Url":"https://semanticscholar.org/paper/29c833b9a5e33b684cffcb76fb19997918180136","s2PdfUrl":"","id":"29c833b9a5e33b684cffcb76fb19997918180136","authors":[{"name":"Leo Prasath Arulraj","ids":["2574972"]},{"name":"Andrea C. Arpaci-Dusseau","ids":["1743175"]},{"name":"Remzi H. Arpaci-Dusseau","ids":["1703415"]}],"journalName":"","paperAbstract":"We introduce Sky, an extension to the VMM that gathers insights and information by intercepting system calls made by guest applications. We show how Sky gains three specific insights -- guest file-size information, metadata-data distinction, and file-content hints -- and uses said information to enhance virtualized-storage performance. By caching small files and metadata with higher priority, Sky reduces the runtime by 2.3 to 8.8 times for certain workloads. Sky also achieves 4.5 to 18.7 times reduction in the runtime of an open-source block-layer deduplication system by exploiting hints about file contents. Sky works underneath both Linux and FreeBSD guests, as well as under a range of file systems, thus enabling portable and general VMM-level optimization underneath a wide range of storage stacks.","inCitations":["7ef329f9b8bc57ec874a6b66b5125d827380bd09"],"pdfUrls":["http://pages.cs.wisc.edu/~arulraj/vee17-sky.pdf","http://doi.acm.org/10.1145/3050748.3050755"],"title":"Improving Virtualized Storage Performance with Sky","doi":"10.1145/3050748.3050755","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050755","venue":"VEE"},
{"entities":["Approximation error","Failure rate","Server (computing)","Systems management","Terminate (software)","Virtual machine","Working set","z/VM"],"journalVolume":"","journalPages":"30-43","pmid":"","year":2017,"outCitations":["54f045c55bbd2a195c9ece257246523289042c40","b53ca4243a5d6a5dfe6fed8ab68d94a43de96716","94a62be8355bf5be1edcc881a26559e5258e0f1d","5642285d925bb50d6e02d9a6f636ad8d18fd1bdd","60e0d1038c8aed966ab5b73700384991e4991291","6d12f09a14d4b1cf7fda642415e752741176cfd8","ae0bce3a6612598250a74d3fc32c91e2b72a8a4c","2a34289c09e7f60daf2838dcd55630080f95614d","2dbd5a76b10508c732aa1cbc858099836a670d15","056e8dad8fa0e33a65981d9d4d9d3a50459c4861","3574657705475722b6c398c266805f758268778b","21843a9de32675bc961bd0929ce6ab50215e1888","23d7da91f129c28bb78df775badfce8bc480c9bd","70458452066e724e5ff29c0c74046e816765beb5","ef7bbede9cacd49b4cadd33458bcfbd49439c9c0","1ee5679595d45f50ce33e9f1dd045b2da4ce0a2b","2819b4f9ccae4ba8b9b7b9cf6b81081c41d4adc4","4dc430f2439cc690eea612d5ef3e24c161938c80","b6f3eb0b06c5ca5f4ce20b18b20d90aa51f00d8b","5fe4eb1749a823469950456a123c77530e33ad73","edd832899e1743c0a53e430d4aa13efac363af2b","b2575e0081ad3cac5f34494de893b6bb0bf594b5","a102b668ab736bb2dc6a41195620fb6b3865289b","6560d5255cfa785b89b5b7e851b78db5fefeb2fd","2a2b0a6e141faad24e105942a814044ee8a203d7","8cb8de207db21b86e121876303e6b4ec4e4a9a6f","7a280c6cdc0ab18f8809b7101330702bfd5bb759","336c1e3936ce150907b50f624b060bdb43d5e11b","2f2cdd7b0c98b5e43b61272d2ac3ebb5cd29041d","65c63845eedb72e437fed64e37e43a0d59fa8471","3debcf6371ed03f441bf32e8e452a2ac6dd54d7b","2238862d65174d55763a61bf0c2e28c96191a084","5bc690391cb140731f88c8a68b4dee6dacd7097d","35f3020a9ebb8180efefd17cff274e91c9ea873d","24dc8d1de7e78ab100d2d83cbdf1390ddb9234c9","262e3ef815bcfbf6e443c812ea55e6381f332934","09a8a5cd0e6caa3ffa39afae01bea3575aa0bbf5","2bef12742683926a29888fda5798ac32d12a30fd"],"s2Url":"https://semanticscholar.org/paper/2b07c44cb9f08d8d4e0d5357dd8fbc6eab197bf1","s2PdfUrl":"","id":"2b07c44cb9f08d8d4e0d5357dd8fbc6eab197bf1","authors":[{"name":"Jinshi Zhang","ids":["4605438"]},{"name":"Eddie Dong","ids":["10384604"]},{"name":"Jian Li","ids":["26846526"]},{"name":"Haibing Guan","ids":["7203366"]}],"journalName":"","paperAbstract":"Live migration of a virtual machine (VM) is a powerful technique with benefits of server maintenance, resource management, dynamic workload re-balance, etc. Modern research has effectively reduced the VM live migration (VMLM) time to dozens of milliseconds, but live migration still exhibits failures if it cannot terminate within the given time constraint. The ability to predict this type of failure can avoid wasting networking and computing resources on the VM migration, and the associated system performance degradation caused by wasting these resources. The cost of VM live migration highly depends on the application workload of the VM, which may undergo frequent changes. At the same time, the available system resources for VM migration can also change substantially and frequently. To account for these issues, we present a solution called MigVisor, which can accurately predict the behaviour of VM migration using working-set model. This can enable system managers to predict the migration cost and enhance the system management efficacy. The experimental results prove the design suitability and show that the MigVisor has a high prediction accuracy since the average relative error between the predicted value and the measured value is only 6.2%~9%.","inCitations":[],"pdfUrls":["http://doi.acm.org/10.1145/3050748.3050753"],"title":"MigVisor: Accurate Prediction of VM Live Migration Behavior using a Working-Set Pattern Model","doi":"10.1145/3050748.3050753","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050753","venue":"VEE"},
{"entities":["Central processing unit","Data deduplication","Graphics processing unit","Kernel same-page merging","Linux","Refresh rate","Virtual machine"],"journalVolume":"","journalPages":"44-59","pmid":"","year":2017,"outCitations":["3eecc905a579d435068bf7df7280abf5f606ba33","04704080ae469d24797ee6369f2e2a72ffcca828","b5ff5af19f737db653f5e14690967166f2a4beea","a205801dbd56f93f3b98fd6d9a535ed1961806fa","242b5b545bb17879a73161134bc84d5ba3e3cf35","c934afd425f7c0aeacf75c7f0aec71d70e1d0e79","5b33afa07e0c428724073de51200c8b8051825c1","43cf61960c85339deeeeeb2b75cdf9595565afa8","045729ec838ecc50be166fe4511506ac4a08226d","7d3fe94b51306badb8ae65ec11fc89a1e4782e02","0be302437cec82b9200d61d13d3125e62a8ef499","5e59d68dd32830d465ae2d739a8f7f5fba52f8e5","07042865b10297ca4fc9164829d6330db2f60b4c","5fe4eb1749a823469950456a123c77530e33ad73","45472bef11491245ad51dde6963e3cc40c5f3b79","86337138bb6dfabef8e1d45ec3c4e30d64c3ce36","6debd9d773c7aca19f18f3b4640c45f8ae12b254","0967839ec5595b6379df1d4d494d8535dffc6575","1ddd08b8610ffe95cb85d2aab2ff08c2722c9772","2ee01ab9aca4163d391bd29c2123d9be44b0e986","7d729347a96424bbbd1a114b78e65ea391be3160","10551c91b4d36d1009b23b4d2b88a9e1733fe029","3bfe2c5558224de412c3dafcefe2b80a5fc78cf5","445728ecb0eabed9f7433b0c96bd36d53cb312c9","1506e49a71ffcc4d201928dbc76a881608c9c6c4","d985c93917cd0a145451ec2c02c9e25d988ac368"],"s2Url":"https://semanticscholar.org/paper/715f72c533b18495a2f8a23811f1e0b6034e42c6","s2PdfUrl":"","id":"715f72c533b18495a2f8a23811f1e0b6034e42c6","authors":[{"name":"Anshuj Garg","ids":["1859608"]},{"name":"Debadatta Mishra","ids":["2484837"]},{"name":"Purushottam Kulkarni","ids":["1749860"]}],"journalName":"","paperAbstract":"Content based page sharing techniques improve memory efficiency in virtualized systems by identifying and merging identical pages. Kernel Same-page Merging (KSM), a Linux kernel utility for page sharing, sequentially scans memory pages of virtual machines to deduplicate pages. Sequential scanning of pages has several undesirable side effects---wasted CPU cycles when no sharing opportunities exist, and rate of discovery of sharing being dependent on the scanning rate and corresponding CPU availability. In this work, we exploit presence of GPUs on modern systems to enable rapid memory sharing through targeted scanning of pages. Our solution, Catalyst, works in two phases, the first where pages of virtual machines are processed by the GPU to identify likely pages for sharing and a second phase that performs page-level similarity checks on a targeted set of shareable pages. Opportunistic usage of the GPU to produce sharing hints enables rapid and low-overhead duplicate detection, and sharing of memory pages in virtualization environments. We evaluate Catalyst against various benchmarks and workloads to demonstrate that Catalyst can achieve higher memory sharing in lesser time compared to different scan rate configurations of KSM, at lower or comparable compute costs.","inCitations":[],"pdfUrls":["https://www.cse.iitb.ac.in/~puru/research/pubs/paper/vee2017-catalyst.pdf","http://doi.acm.org/10.1145/3050748.3050760"],"title":"Catalyst: GPU-assisted rapid memory deduplication in virtualization environments","doi":"10.1145/3050748.3050760","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050760","venue":"VEE"},
{"entities":["Cloud computing","Hypervisor","Keystroke logging","Operating system","Virtual machine","z/VM"],"journalVolume":"","journalPages":"157-170","pmid":"","year":2017,"outCitations":["c25a66d96e796b5cc013607153ff2a0e139c93ad","3574657705475722b6c398c266805f758268778b","009af3a1fa932ea1a9efa8d34cb0b6e32feae15e","0a22675c7bd5729b06816e3788f7b906d029ca03","5752a746cd143d30b22d837e1077fa9c971860fb","0abc3e83ccd6e685f8d0299f24f03ae28f4c2459","97cdcc50199a9c1f7f47deffee3fe869fd968220","42286822d70bdd531abf8aea29e7a73086e949d5","2960c89331eb7afa86584792e2e11dbf6a125820","9df577f0e884db39bff445b58757e6a3f42ca1b5","883f3778fcb560c555f7ea7a64fa061e70e7f256","82d236d0df331988c7482228d63a560316149bae","93e6deb8ac31807df341728a469984add00aed27","4162ec72047f0af323e11494ed3a6ecfe6beffe1","76b73a657ef1cb543790acc99fc8abc80dbe4fc7","bebe4a03f445e8460fd7664b92ce30f21895bf7a","0edd896bc82b7fb65ef63cb1e3512db795c7f7d4","1d811442b124056060f8ba236e09376b26dacede","4ac3a866bc1ce82a67f2cf00dca9ec1349598c07","3fcc6e3eaa94aec4612b7225b167ac003a370e20","3f8c6ecb15bbdf667ec6bbe1b132db1945110976","2e8da51c545cbe8e62a3751a5a2b9a3beca00b43","2723d4dc7884d1237b315edc39f9fe345885d8ea","2c628dedb6a1fb0c566ec791c84b93a22dd9aaa9","88b6a71ad0f166769c3c51cbe802c972d524a78f","4ab4a666f5e5ed34ac219a9fdc2f70bd1cab0922","86013daaae16572bceb755e65ee5fa2fdfb63848","6c0562ffc00ba7a4d2734ac039ffd181afe2008d"],"s2Url":"https://semanticscholar.org/paper/45b63f73b1512b8181f8243129951a8538773060","s2PdfUrl":"","id":"45b63f73b1512b8181f8243129951a8538773060","authors":[{"name":"Zachary Estrada","ids":["2086958"]},{"name":"Read Sprabery","ids":["2493219"]},{"name":"Lok Yan","ids":["2805337"]},{"name":"Zhongzhi Yu","ids":["10385489"]},{"name":"Roy H. Campbell","ids":["1687256"]},{"name":"Zbigniew T. Kalbarczyk","ids":["1687748"]},{"name":"Ravishankar K. Iyer","ids":["1686653"]}],"journalName":"","paperAbstract":"This paper extends the concepts behind cloud services to offer hypervisor-based reliability and security monitors for cloud virtual machines. Cloud VMs can be heterogeneous and as such guest OS parameters needed for monitoring can vary across different VMs and must be obtained in some way. Past work involves running code inside the VM, which is unacceptable for a cloud environment. We solve this problem by recognizing that there are common OS design patterns that can be used to infer monitoring parameters from the guest OS. We extract information about the cloud user's guest OS with the user's existing VM image and knowledge of OS design patterns as the only inputs to analysis. To demonstrate the range of monitoring functionality possible with this technique, we implemented four sample monitors: a guest OS process tracer, an OS hang detector, a return-to-user attack detector, and a process-based keylogger detector.","inCitations":[],"pdfUrls":["http://doi.acm.org/10.1145/3050748.3050759","http://assured-cloud-computing.illinois.edu/files/2014/03/Using-OS-Design-Patterns-to-Provide-Reliability-and-Security-as-a-Services-for-VM-based-Clouds.pdf"],"title":"Using OS Design Patterns to Provide Reliability and Security as-a-Service for VM-based Clouds","doi":"10.1145/3050748.3050759","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050759","venue":"VEE"},
{"entities":["Amazon Elastic Compute Cloud (EC2)","Central processing unit","Change detection and notification","GB-PVR","Hypervisor","Simulation","Uptime","X86"],"journalVolume":"","journalPages":"15-29","pmid":"","year":2017,"outCitations":["592527217d62cf196df1545a555165dc9bc8fa3d","0387c89a21e113eb69fcde8a11c82a072e3a1af1","0719fda19d92123715c98f872fb857fec7803aba","c7f3a75479a42b242e9c9ebcd17b521d850e836a","7da24bcadf4df972057c208372293e2da68fd8ac","0a7d32cd957055bcc475edaa97d5e4890eec0446","5017593f65d08a4b6072f60af89ff961ec76c9df","38fb66c959ef2bdfb11c6ac7c7ca37d635d1dafc","4cead48e2eac91560105871b78268e3164eb382b","4ab925447eda3627162919aee0b4863f0cd75c80","60141685abac0d670eac915a0acbc258ccf235a4","380645605e14aa824bdbd50bab86566def7221d1","35f1dbf5079b2383bc580161fcddbef960e64e2c","048d6cee0d6764932f886d93e641235e7e7a60fa","a93cfc7d891492c9bfdfe129b8077b3a2f41fe08","03d1048cff1e12d46f6aa382bb438b06f6c3a2ad","7129b305ce45f83127e928e8510da9fae0783905","5b7561f44f95ab68dbedb839849cbe72313aef20","266c9e256ee30065765aba238cabd8c5b029372a","65fd142f37c315cdf892184f8fb21281b88f6269","c20e9557baa6333832e83e5b4cbbb6a359fa6885","2f57f5aa940bd000c45e12431e258dc6d5de9acd","76ca7b8a3c66a2381ee3d58d5e6e05e89cb1ca2a","22bd3a35b9550bc5b570a0beee5648eb9033be3b","0860bc34aac8a304674aa4c205ff46e6dbc93295","05e00789898c6d964d8aaedd5c3acd4f9c7c4d6f","5cfc936d12bbd8a0f100687b12b20e406215f30a"],"s2Url":"https://semanticscholar.org/paper/86c78adba2c8791d3d3e70c927504b2c7e259528","s2PdfUrl":"","id":"86c78adba2c8791d3d3e70c927504b2c7e259528","authors":[{"name":"Simon Kuenzer","ids":["2388918"]},{"name":"Anton Ivanov","ids":["3118329"]},{"name":"Filipe Manco","ids":["2297493"]},{"name":"Jose Mendes","ids":["8627779"]},{"name":"Yuri Volchkov","ids":["10414012"]},{"name":"Florian Schmidt","ids":["40279556"]},{"name":"Kenichi Yasukata","ids":["2613133"]},{"name":"Michio Honda","ids":["1895414"]},{"name":"Felipe Huici","ids":["2963590"]}],"journalName":"","paperAbstract":"Video streaming dominates the Internet's overall traffic mix, with reports stating that it will constitute 90% of all consumer traffic by 2019. Most of this video is delivered by Content Delivery Networks (CDNs), and, while they optimize QoE metrics such as buffering ratio and start-up time, no single CDN provides optimal performance. In this paper we make the case for elastic CDNs, the ability to build virtual CDNs on-the-fly on top of shared, third-party infrastructure at a scale. To bring this idea closer to reality we begin by large-scale simulations to quantify the effects that elastic CDNs would have if deployed, and build and evaluate MiniCache, a specialized, minimalistic virtualized content cache that runs on the Xen hypervisor. MiniCache is able to serve content at rates of up to 32 Gb/s and handle up to 600K reqs/sec on a single CPU core, as well as boot in about 90 milliseconds on x86 and around 370 milliseconds on ARM32.","inCitations":["a46da31446c98c59d88e8cf626d0dd917b12d93e","c01f0c08545d3abf85b59c15f0bb7ce0dc03ebcb","70c4f0403d80427e10c7e7167f814ec0bb12d18f","d5f1b82f43c51b0ba5aeb7132457a58b54b8308d"],"pdfUrls":["http://doi.acm.org/10.1145/3050748.3050757"],"title":"Unikernels Everywhere: The Case for Elastic CDNs","doi":"10.1145/3050748.3050757","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050757","venue":"VEE"},
{"entities":["Broadcast automation","Code injection","DevOps","KVM switch","Live CD","Machine code","Memory footprint","Software bug","System monitoring"],"journalVolume":"","journalPages":"97-111","pmid":"","year":2017,"outCitations":["8cbb73828527b1965e1cfb6a104f5ce7cf1ce3ce","41094fdc5f833c85c488b3fb2bade1ecde006efe","1d99b7749a9311d2db24a3d84728e444eff23e4b","5cd50a34d1418de1f8c57bc447e1407d561a42e1","595bdc4d40c7696b829f8f2e45645fe0bb6154ef","e093cdd49561d4739f300fd05c0eb09ec719376a","62d6d99866697d5efdbba3df89051f9c96082567","68dfa99bf31b85ce964edc2b7deb241af3c87527","893e818f5cc7a160befd613131717fd2fd0f2ef8","b634f4f4ff14c87952ba2713faad763753d34684","3611a72405a106d8fc4682ab7dd32b8f241f3690","5075192e0e25af961420412fed1f848282ae313e","32a7c5e10a09b5532d56af50ef2f60d9776cc56a","f054c1489516b19704398b343ddbd41f3aa2c4e0","1dc8960ee89252ba82d881b17211542017e4c597","4ab4a666f5e5ed34ac219a9fdc2f70bd1cab0922","07a849ef5c6efe194bf37027280eca63252cf21e","4efe82c7ff97fb8e2b36a57d7431ddf8ac9382e4","30d9132ef7845b8fb4e53d9ad982363700746928","ca81be25da20dc29cc0a6deca1f6b285d7cf0975","27f071ccbea5a4940dcc585ba4cfa9258bf2bcdf","09d4c0b113ec0174bca0d4b0632814094a5cf14f","1a16c05b5e002bcb117d892fe4101d58ad8ac6c9","b3f7942b994d65cd72556487b45c7367bc9546ad","1c676ab6b80c76533c6d92758dd96768f51cb6a9","02ed0ec3bb95776b5c06e2784810b501c4d3f053","174f8fdd45609c8962ffb9f997898128e44afeda","9aa0d7253574e50fe3a190ccd924433f048997dd","5d841fce8946ad9cbf6960827fa402b3551cc4c3","6a1249f6eeed047ace81012c7578fe42f26b776f","33623a9fec52e01e92c6ba1ae4d67b01f0c76fe5","5fbf3dc6055f79a56cff1b2d3caf614081afcdba","65192f3d0ffb066a4c47a09fc11fdfad47dd192e","3cda09fdc91d7f85a138a4d56848a3a0708df76f","340569da290505865cb2ba79a4201c7028d4d66a","2df18f420ed0669c1bec74038d2ad068bf0831a2","1c7e1a0bde89990a9173664d3ff6931542741226","441cf0fe8091d09207374a9d96723419091345ab","9bc637db1e3c0dbcde1b44139a08d50737aca116","4650259fb4aadb376fd5994f9ab9dd07a4f83511","b8b3b0b974f76abdf7d5be2cba019cecaedb8e17","5752a746cd143d30b22d837e1077fa9c971860fb","78bae2bd40431d495895cf60c126ee54fdcdf743","24748ef2b88e6df370b5dccfb75cba47e132f92d","63759a83f74f7637ed16c6b9de362b9349ee3d31","1b43f9272d8806feae6460a02a5296f10efcfeee","948ad0102d49842e7a785140a67cdf28c0c4567e","02f28656a748c351bf92c76c5a0a31c2d1d9c45d","2d5d6fceb2d20df7f9ed324f82afe73688dd9ed4","1ce158e7922ad56e6b065026f50f12c94eb786f2","bf0da9dadafe58af41801f7097d51c9442c79148","3ec4b8237c86c4cccee8b4002dfabecb20d1c511","04c43bcb8b233052a08a6a42f57398c6ce91e234","b06c7df9404cf6d87b5d552808450b8c226deab9","0187493c5cbd9b8bcf2019b8521082aea6db83f1"],"s2Url":"https://semanticscholar.org/paper/17ed47ae223da909afc9f7213f08146534b45ae9","s2PdfUrl":"","id":"17ed47ae223da909afc9f7213f08146534b45ae9","authors":[{"name":"Sahil Suneja","ids":["40005837"]},{"name":"Ricardo Koller","ids":["6100194"]},{"name":"Canturk Isci","ids":["1765914"]},{"name":"Eyal de Lara","ids":["1879216"]},{"name":"Ali B. Hashemi","ids":["40552834"]},{"name":"Arnamoy Bhattacharyya","ids":["39231157"]},{"name":"Cristiana Amza","ids":["1734109"]}],"journalName":"","paperAbstract":"With DevOps automation and an everything-as-code approach to lifecycle management for cloud-native applications, challenges emerge from an operational visibility and control perspective. Once a VM is deployed in production it typically becomes a hands-off entity in terms of restrictions towards inspecting or tuning it, for the fear of negatively impacting its operation. We present CIVIC (Cloning and Injection based VM Inspection for Cloud), a new mechanism that enables safe inspection of unmodified production VMs on-the-fly. CIVIC restricts all impact and side-effects of inspection or analysis operations inside a live clone of the production VM. New functionality over the replicated VM state is introduced using code injection. In this paper, we describe the design and implementation of our solution over KVM/QEMU. We demonstrate four of its use-cases-(i) safe reuse of system monitoring agents, (ii) impact-heavy problem diagnostics and troubleshooting, (iii) attaching an intrusive anomaly detector to a live service, and (iv) live tuning of a webserver's configuration parameters. Our evaluation shows CIVIC is nimble and lightweight in terms of memory footprint as well as clone activation time (6.5s), and has a low impact on the original VM (&lt; 10%).","inCitations":[],"pdfUrls":["http://doi.acm.org/10.1145/3050748.3050766","http://www.eecg.toronto.edu/~amza/papers/vee17-paper.pdf","http://sysweb.cs.toronto.edu/publication_files/0000/0305/Civic_VEEFinalVersion_1_.pdf"],"title":"Safe Inspection of Live Virtual Machines","doi":"10.1145/3050748.3050766","sources":["DBLP"],"doiUrl":"https://doi.org/10.1145/3050748.3050766","venue":"VEE"},
